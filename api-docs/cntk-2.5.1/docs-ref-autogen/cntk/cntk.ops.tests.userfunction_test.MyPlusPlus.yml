### YamlMime:PythonClass
uid: cntk.ops.tests.userfunction_test.MyPlusPlus
name: MyPlusPlus
fullName: cntk.ops.tests.userfunction_test.MyPlusPlus
module: cntk.ops.tests.userfunction_test
inheritances:
- cntk.ops.tests.userfunction_test.MyPlus
constructor:
  syntax: MyPlusPlus(*args, **kwargs)
methods:
- uid: cntk.ops.tests.userfunction_test.MyPlusPlus.deserialize
  name: deserialize
  summary: 'A stub deserialize method for illustration purposes. User-defined functions

    need to provide their own implementation in order for CNTK to be able to

    reconstruct them when loading a model.'
  signature: static deserialize(*args)
  parameters:
  - name: inputs
    description: a list of inputs to the function
    isRequired: true
    types:
    - <xref:list>
  - name: name
    description: name of this function
    isRequired: true
    types:
    - <xref:str>
  - name: state
    description: 'a state dictionary generated by the corresponding

      <xref:cntk.ops.functions.UserFunction.serialize> method.'
    isRequired: true
    types:
    - <xref:dict>
  return:
    description: An instance of the user-defined function.
- uid: cntk.ops.tests.userfunction_test.MyPlusPlus.forward
  name: forward
  summary: 'Computes the values of speficied variables in `outputs`, using values

    provided in `arguments` that correspond to each input *Variable* of

    the function (i.e. those that have `is_input = True`).'
  signature: forward(*args, **kwargs)
  parameters:
  - name: arguments
    description: "maps variables to their input data. The interpretation depends on\n\
      the input type:\n\n   * dict: keys are input variable or names, and values are\
      \ the input data. To specify a minibatch, provide a list of arrays. The shape\
      \ of each array must be compatible with the shape of the dictionary key. If\
      \ the array denotes a sequence then the elements of the sequence are grouped\
      \ along axis 0. \n\n   * any other type: if node has a unique input, arguments\
      \ is mapped to this input. \n\nFor nodes with more than one input, only dict\
      \ is allowed.\n\nIn both cases, every sample in the data will be interpreted\n\
      as a new sequence.\n\nSequences can be marked as continuations of the same sequence\
      \ in\nthe previous minibatch (that is the sequence in the same slot).\nThere\
      \ are two possibilities for this:\n\n   * specifying arguments as a *tuple*\
      \ where the first element is used as arguments and the second one will be used\
      \ as a list of bools, denoting whether a sequence is a new one (*True*) or a\
      \ continuation of the sequence in the same slot of the previous minibatch (*False*).\
      \ This will be applied to all batches. \n\n   * specifying arguments as a dictionary\
      \ of variables to tuples where the first element is used as arguments and the\
      \ second one will be used as a list of bools, denoting whether a sequence is\
      \ a new one (*True*) or a continuation of the sequence in the same slot of the\
      \ previous minibatch (*False*). This will be applied to all batches. \n\nData\
      \ should be either NumPy arrays or a\n<xref:cntk.io.MinibatchData> instance."
    isRequired: true
  - name: outputs
    description: 'outputs to fetch values for. If not

      set, all outputs of the function will be fetched.'
    isRequired: true
    types:
    - <xref:iterable>, <xref:optional>
  - name: keep_for_backward
    description: 'the subset of the

      Function''s output variables for which gradients shall be calculated

      in a subsequent backward call. If *None*, the returned state will

      be *None* and a subsequent call to <xref:cntk.ops.tests.userfunction_test.backward>
      will not be

      possible.'
    isRequired: true
    types:
    - <xref:set>, <xref:default None>
  - name: device
    description: 'the device

      descriptor that contains the type and id of the device on which the

      computation is. If *None*, the default device is used.'
    isRequired: true
    types:
    - <xref:cntk.device.DeviceDescriptor>, <xref:default None>
  - name: as_numpy
    description: 'whether to return the result as a NumPy array. Default True.

      Specifying this as False returns a CNTK Value which avoids a

      costly conversion but returns a somewhat opaque object. Also, the Value objects

      are temporary and only guaranteed to be valid until the next forward/eval/backward/grad
      call.

      You must explicitly clone the temporay Value objects if they need to be accessed
      later.'
    isRequired: true
    types:
    - <xref:bool>
  return:
    description: 'A tuple (BackPropState, map of outputs to NumPy arrays). The

      BackPropState is a handle taken by <xref:cntk.ops.tests.userfunction_test.backward>.'
  examples:
  - "\n```\n\n>>> # Doing the same, but with a CSR matrix from scipy.sparse\n>>> vocab_size\
    \ = 5\n>>> from scipy.sparse import csr_matrix\n>>> v = C.sequence.input_variable(shape=(vocab_size,),\
    \ is_sparse=True)\n>>> f = C.times(v, np.eye(vocab_size))\n>>> # Note that csr_matrix\
    \ automatically uses a sparse representation underneath.\n>>> sparse_batch = [csr_matrix([[0,1,0,0,0]]),\
    \ csr_matrix([[0,0,1,0,0], [0,0,0,0,1]])]\n>>> _, fv = f.forward({v:sparse_batch})\n\
    >>> list(fv.values())[0]\n[array([[ 0.,  1.,  0.,  0.,  0.]], dtype=float32),\n\
    \ array([[ 0.,  0.,  1.,  0.,  0.], [ 0.,  0.,  0.,  0.,  1.]], dtype=float32)]\n\
    \n>>> # Much more efficient, however, is to incrementally create CSR arrays.\n\
    >>> # See https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html\n\
    >>> # for more information.\n>>> def seq_to_csr_matrix(seq, vocab_size):\n...\
    \     indptr = [0]\n...     indices = []\n...     data = []\n...     for term_idx\
    \ in seq:\n...         indices.append(term_idx)\n...         data.append(1)\n\
    ...         indptr.append(len(indices))\n...     return csr_matrix((data, indices,\
    \ indptr), shape=(len(seq), vocab_size))\n>>> sparse_batch = [seq_to_csr_matrix(seq,\
    \ vocab_size) for seq in batch]\n>>> _, fv = f.forward({v:sparse_batch})\n>>>\
    \ list(fv.values())[0]\n[array([[ 0.,  1.,  0.,  0.,  0.]], dtype=float32),\n\
    \ array([[ 0.,  0.,  1.,  0.,  0.], [ 0.,  0.,  0.,  0.,  1.]], dtype=float32)]\n\
    ```\n"
- uid: cntk.ops.tests.userfunction_test.MyPlusPlus.serialize
  name: serialize
  summary: 'Generates a dictionary that captures the state of this user-defined function.

    This method must be overridden, if a user function has any state that needs

    to be preserved in the model dictionary.'
  signature: serialize()
